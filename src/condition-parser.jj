options
{
  LOOKAHEAD= 3;

  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(condition_parser)
import java.util.ArrayList;
import alice.tuprolog.*;
import java.io.*;
public class condition_parser
{
 public static void main(String args[]) throws ParseException, FileNotFoundException {
    condition_parser parser = new condition_parser(new FileInputStream("./src/QueryParserTest1.txt"));
    Query query = parser.query();
    System.out.println(query.toString());
 }
}
PARSER_END(condition_parser)
SKIP :
{
        " "
    |   "\r"
    |   "\t"
    |   "\n"
    |   "\r\n"
}
TOKEN :
{
      <NAME: "Name">
    | <CAPBASE: "Capability Base">
    | <BELBASE: "Belief Base">
    | <GOALBASE: "Goal Base">
    | <PLANBASE: "Plan Base">
    | <GP_RULES: "Goal Planning Rule Base">
    | <PR_RULES: "Plan revision Rule Base">
    | <COMMA: ",">
    | <COLON: ":">
    | <PROLOGEND: ".">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <AND: "and">
    | <OR: "or">
    | <IF: "if">
    | <WHILE: "while">
    | <DO: "do">
    | <THEN: "then">
    | <ELSE: "else">
    | <SEMICOL: ";">
    | <NONE: "None">
    | <SEND: "Send">
    | <JAVA: "Java">
    | <LPAR: "(">
    | <RPAR: ")">
    | <VBAR: "|">
    | <QUSMARK: "?">
    | <TRUE: "true">
    | <NOT: "not">
    | <IMPLY: "<-">
    | <GIVES: ":-">
    | <VAL: (((["a"-"z"]) (["A"-"Z"] | ["a"-"z"] | "_" | ["0" - "9"])*) | (["0" - "9"])+)>
    | <VAR: (["A"-"Z"] | "_") (["A"-"Z"] | ["a"-"z"] | "_" | ["0" - "9"])*>
    | <ATOM: (<VAL> | <VAR>)>
}


Query query():
{
    Query sub0;
    Query sub1;
    boolean isOr;
}
{
    (sub0 = singlequery() {return sub0;})
    | (<LPAR> sub0 = query() ((<OR> sub1 = query() <RPAR> {return new wffBinary(true, sub0, sub1);}) |
    (<AND> sub1 = query() <RPAR> {return new wffBinary(false, sub0, sub1);})))
}


Query singlequery():
{
    Query query;
}
{
    (query = truequery() {return query;}) | (query = literal() {return query;})
}


TrueQuery truequery():
{
}
{
    <TRUE> {return new TrueQuery();}
}


Literal literal():
{
    VpredClause clause;
}
{
    (clause = vpredclause() {return new Literal(false, clause);}) | (<NOT> clause = vpredclause() {return new Literal(true, clause);})
}


GpredClause gpredclause():
{
    Token t;
    ArrayList<Atom> arguments = new ArrayList<Atom>();
    Atom buffer;
}
{
    t = <VAL> <LPAR> (buffer = val() {arguments.add(buffer);} )? (<COMMA> buffer = val() {arguments.add(buffer);})* <RPAR>
    {return new GpredClause(t.image, arguments);}
}


VpredClause vpredclause():
{
    Token t;
    ArrayList<Atom> arguments = new ArrayList<Atom>();
    Atom buffer;
}
{
    t = <VAL> <LPAR> (buffer = atom() {arguments.add(buffer);} )? (<COMMA> buffer = atom() {arguments.add(buffer);})* <RPAR>
    {return new VpredClause(t.image, arguments);}
}


Atom val():
{
    Token t;
}
{
    t = <VAL>{return new Atom(t.image);}
}


Atom var():
{
    Token t;
}
{
    t = <VAR>{return new Atom(t.image);}
}


Atom atom():
{
    Atom a;
}
{
    a = var() {return a;}| a = val() {return a;}
}